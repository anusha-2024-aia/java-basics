import java.util.ArrayList;

/**
 * PrimeNumberCalculator
 * Calculates primes up to 50.
 */
public class PrimeNumberCalculator {

    public static void main(String[] args) {
        int limit = 50;
        ArrayList<Integer> primes = new ArrayList<>();

        System.out.println("Calculating prime numbers up to " + limit + "...");

        for (int i = 2; i <= limit; i++) {
            if (isPrime(i)) {
                primes.add(i);
            }
        }

        System.out.println("Primes found: " + primes.size());
        System.out.print("Prime Numbers: ");
        for (int i = 0; i < primes.size(); i++) {
            System.out.print(primes.get(i) + (i == primes.size() - 1 ? "" : ", "));
        }
        System.out.println();
    }

    /**
     * Checks if a number is prime.
     * @param n The number to check
     * @return true if prime
     */
    public static boolean isPrime(int n) {
        if (n <= 1) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
}
// Line 39
// Line 40
// Line 41
// Line 42
// Line 43
// Line 44
// Line 45
// Line 46
// Line 47
// Line 48
// Line 49
// Line 50


from sklearn.datasets import load_wine  # Changed from load_iris
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, confusion_matrix

# Load dataset
wine = load_wine()  # Load Wine data instead of Iris
X = wine.data
y = wine.target

# Split dataset into train and test
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42)

# Create k-NN classifier
knn = KNeighborsClassifier(n_neighbors=3)

# Train the model
knn.fit(X_train, y_train)

# Predict test data
y_pred = knn.predict(X_test)

# Accuracy
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

# Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:\n", cm)

# k-Fold Cross Validation
cv_scores = cross_val_score(knn, X, y, cv=5)
print("Cross Validation Scores:", cv_scores)
print("Average CV Accuracy:", cv_scores.mean())

import re
from collections import Counter

# --- 40 Lines of Code: Log Analyzer ---
def analyze_log(file_path):
    error_patterns = {
        'DatabaseError': r'DB_ERR: (.*)',
        'NetworkTimeout': r'NET_TIMEOUT: (.*)',
        'SyntaxError': r'SYNTAX_ERR: (.*)'
    }
    error_counts = Counter()
    total_lines = 0

    try:
        with open(file_path, 'r') as file:
            for line in file:
                total_lines += 1
                for error_type, pattern in error_patterns.items():
                    if re.search(pattern, line):
                        error_counts[error_type] += 1
    except FileNotFoundError:
        return "File not found."

    # Generate Summary
    summary = []
    summary.append("="*30)
    summary.append("LOG ANALYSIS REPORT")
    summary.append("="*30)
    summary.append(f"Total Lines: {total_lines}")
    summary.append(f"Errors Found: {sum(error_counts.values())}")
    summary.append("-" * 30)
    for err, count in error_counts.most_common():
        summary.append(f"{err}: {count}")
    summary.append("="*30)
    
    return "\n".join(summary)

# --- Usage Example ---
# Create a dummy log file for demonstration
with open("app.log", "w") as f:
    f.write("INFO: System started\n")
    f.write("DB_ERR: Connection lost\n")
    f.write("INFO: Retrying\n")
    f.write("NET_TIMEOUT: Request timed out\n")
    f.write("DB_ERR: Connection lost\n")

# Run the analyzer
print(analyze_log("app.log"))
